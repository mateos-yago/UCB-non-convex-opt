function loss_table = mse_plot_ucb_trajectories(M, Y0, n_iters, opts)
%MSE_PLOT_UCB_TRAJECTORIES UCB-based Gradient Descent trajectories.
%
%   UCB selection over K initializations (arms) to minimize a non-convex
%   loss by gradient descent, over the scalar-loss landscape defined by
%   polyflow.mse_build_model.
%
%   Each arm is a 2n-dimensional vector x = [a; b], where
%       a, b ∈ R^n.
%   The loss for one arm is
%       l(a,b) = sum_{j=1}^n L(a_j, b_j),
%   where M.L is the scalar loss L(a,b) and M.gradL its scalar gradient
%   [dL/da; dL/db].  This function builds l and ∇l internally.
%
%   Inputs
%   ------
%     M    : struct generated by polyflow.mse_build_model
%
%     Y0   : (2n)×K or K×(2n) matrix of initial conditions (K arms)
%
%     n_iters : total number of global UCB iterations
%
%     opts : struct with optional fields
%               .eta            : learning rate (default 0.01)
%               .linewidth      : line width for trajectories (default 1.5)
%               .colors         : K×3 color matrix (default: lines(K))
%
%   Figures
%   -------
%     1) Phase portrait (polyflow.mse_phaseportrait) with trajectories of
%        the first coordinate pair (a1,b1) for each arm overlaid.
%     2) Loss vs. number of pulls:
%          - x-axis: for each arm, its own pull index (1,2,...,N_k).
%          - curves only at descent steps for each arm, with markers.
%          - continuous red horizontal line at the analytic minimum.
%     3) Bar plot of the final number of pulls per arm.
%
%   Output
%   ------
%     loss_table : table with columns
%                     step, loss_arm_1, ..., loss_arm_K
%                  where loss_arm_k(t) is l(a,b) for arm k after global
%                  iteration t.

    if nargin < 4, opts = struct(); end

    % ----- Default options -----
    if ~isfield(opts, 'eta'),       opts.eta       = 0.01; end
    if ~isfield(opts, 'linewidth'), opts.linewidth = 1.5;  end

    % Number of global steps
    n_steps = n_iters;

    % ----- Initialize arms -----
    % Require Y0 to be (2n)×K 
    [dim, K] = size(Y0);
    
    if mod(dim, 2) ~= 0
        error('Y0 must be of size (2n)×K with an even number of rows.');
    end
    
    n = dim / 2;  % number of (a,b) pairs per arm

    if ~isfield(opts, 'colors'), opts.colors = lines(K); end

    X = Y0;                % current positions of all K arms (2n×K)
    N = zeros(1, K);       % pull counts N_k(t)

    % 2D trajectory history (store full vectors; plot first 2 coords)
    history = cell(1, K);
    for k = 1:K
        history{k} = X(:, k);
    end

    % Loss histories
    loss_hist_all      = nan(n_steps, K); % global iteration loss
    loss_hist_selected = nan(n_steps, K); % only when selected
    pull_hist_selected = nan(n_steps, K); % per-arm local pull index

    % ----- Analytic minimum of the loss -----
    % TODO: in the future, this could be taken from M.
    true_min_loss = 0;

    % ----- Helpers: full loss / full gradient for a 2n-vector -----
    function val = full_loss(x)
        % x is 2n×1: [a; b]
        a = x(1:n);
        b = x(n+1:2*n);
        val = 0;
        for j = 1:n
            val = val + M.L(a(j), b(j));
        end
    end

    function g = full_grad(x)
        a = x(1:n);
        b = x(n+1:2*n);
        ga = zeros(n,1);
        gb = zeros(n,1);
        for j = 1:n
            g_j = M.gradL(a(j), b(j));   % 2×1 gradient [dL/da; dL/db]
            ga(j) = g_j(1);
            gb(j) = g_j(2);
        end
        g = [ga; gb];  % 2n×1
    end

    % ======================================================
    %  FIGURE 1: phase portrait + 2D trajectories (a1,b1)
    % ======================================================
    figure;

    % Draw phase portrait / level sets / critical points:
    polyflow.mse_phaseportrait(M);
    hold on;

    % ----- Main UCB–GD loop -----
    for t = 1:n_steps

        % 1. Compute UCB statistic for each arm:
        %    U_k(t) = tanh(l(x_k(t)))
        %             - sqrt( 2 log(1 + t log^2 t) / (N_k(t)+1) )
        numerator = 2 * log(1 + t*(log(t))^2);

        U = zeros(1, K);
        for k = 1:K
            f_val = full_loss(X(:, k));              % current loss l(a,b)
            f_scaled = f_val / n;

            exploration = sqrt(numerator / (N(k) + 1));
            U(k) = tanh(f_scaled) - exploration;        % LCB for minimization
        end

        % 2. Select arm
        [~, A_t] = min(U);

        % 3. Gradient descent step on selected arm
        gA = full_grad(X(:, A_t));
        X(:, A_t) = X(:, A_t) - opts.eta * gA;

        % 4. Update pull count
        N(A_t) = N(A_t) + 1;

        % Store new position for 2D plotting (first two components)
        history{A_t} = [history{A_t}, X(:, A_t)];

        % 5. Record losses AFTER this step
        for k = 1:K
            loss_hist_all(t, k) = full_loss(X(:, k));
        end

        % Only the selected arm has a descent step at time t:
        % store its loss and its *local* pull index N(A_t)
        loss_hist_selected(t, A_t) = loss_hist_all(t, A_t);
        pull_hist_selected(t, A_t) = N(A_t);
    end

    % Overlay 2D trajectories (first two coordinates) on phase portrait
    for k = 1:K
        traj = history{k};
        if size(traj, 2) > 1
            plot(traj(1,:), traj(2,:), '.-', ...
                 'Color',      opts.colors(k,:), ...
                 'LineWidth',  opts.linewidth, ...
                 'MarkerSize', 8);
            % Mark final position
            plot(traj(1,end), traj(2,end), 'o', ...
                 'Color',           opts.colors(k,:), ...
                 'MarkerFaceColor', opts.colors(k,:), ...
                 'MarkerSize',      4);
        end
    end

    % =====================================================
    %  FIGURE 2: loss vs arm-local pull count + min line
    % =====================================================
    figure;
    hold on;

    % For each arm, x-axis is the number of pulls of *that* arm
    for k = 1:K
        idx = find(~isnan(loss_hist_selected(:, k)));
        if ~isempty(idx)
            x_local = pull_hist_selected(idx, k);   % 1,2,...,N_k
            y_loss  = loss_hist_selected(idx, k);
            plot(x_local, y_loss, '-o', ...
                 'Color',     opts.colors(k,:), ...
                 'LineWidth', 1, ...
                 'MarkerSize', 4);
        end
    end

    % Continuous red horizontal line at analytic minimum
    max_pulls = max(N);  % largest N_k
    x_line = 0:max_pulls;
    plot(x_line, true_min_loss * ones(size(x_line)), ...
         'r-', 'LineWidth', 2);

    xlabel('Number of pulls for each arm');
    ylabel('Loss l(a,b)');
    title('Loss per initialization vs. arm-local pull count');
    grid on;

    % =====================================================
    %  FIGURE 3: bar plot of number of pulls per arm
    % =====================================================
    plot_arm_pull_counts(N, opts.colors);
end

% -------------------------------------------------------------------------
% Helper function: bar plot of how many times each arm was chosen
% -------------------------------------------------------------------------
function plot_arm_pull_counts(N, colors)
    K = numel(N);
    figure;
    b = bar(1:K, N);
    b.FaceColor = 'flat';
    % Color each bar according to the corresponding arm color
    if size(colors,1) >= K && size(colors,2) == 3
        for k = 1:K
            b.CData(k, :) = colors(k, :);
        end
    end
    xlabel('Arm index');
    ylabel('Number of pulls');
    title('Number of pulls per arm');
    grid on;
end
